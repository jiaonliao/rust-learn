/// 基本类型
/// Rust中，每个值都有确切的类型，总的来说可以分为两种：基本类型和复合类型。基本类型意味着它们往往是一个最小化原子类型
/// 基本类型有：
///     -数值类型
///         -有符号整数
///             -i8
///             -i16
///             -i32
///             -i64
///             -i128
///             -isize
///         -无符号整数
///             -u8
///             -u16
///             -u32
///             -u64
///             -u128
///             -usize
///         -浮点数
///             -f32
///             -f64
///         -有理数
///         -复数
///    -布尔类型
///    -字符类型：单个Unicode字符，存储为4个字节
///    -字符串类型：&str和string
///    -单元类型：()，其唯一的值也是()
fn main() {
    // #############类型推导与标注#############
    // 在无法推导类型时，需要手动标注类型
    // 此示例异常，无法确定类型
    // let guess = "42".parse().expect("Not a number!");
    // 明确类型
    let guess: i32 = "42".parse().expect("Not a number!");
    println!("guess:{}", guess);

    // #############整数类型#############
    // 整数类型是没有小数部分的数字，其中，以u开头的整数类型标识无符号整数，以i开头的整数类型标识有符号整数
    // i or u 后的数字标识整形的位数，其中size表示其位数由运行计算机的Cpu类型决定
    // 其字面量的书写有以下格式
    let _ten = 92_000; // 10进制
    let _hex = 0xff;   // 16进制
    let _eight = 0o77; // 7进制
    let _binary = 0b1111_0000; // 二进制
    let _byte = b'a'; //字节，仅限u8

    // #############整数溢出#############
    // 假设此时有一个u8类型的变量，其存储范围为0-255，在存储到255+时，就会发生整形溢出
    // 在debug模式下，rust会检查整形溢出，若存在溢出时，程序会panic
    // 而release模式下，不会检查整形溢出，将会按照补码循环溢出的规则进行处理，即256=0，257=1，程序不会panic，但是该值可能不是你所期望的值
    // 要显式的处理这些潜在问题，可以使用标准库中针对原始数字提供的方法
    // -wrapping_* 方法在所有模式下都按照补码循环溢出的规则进行处理
    // -checked_* 发生溢出时，返回none值
    // -overflowing_* 该方法返回该值和一个指示是否溢出的bool值
    // -saturating_* 该方法使值达到最大或最小值
    let mut overflow: u8 = 255;
    overflow = overflow.wrapping_add(1);
    println!("overflow:{}", overflow);

    // #############浮点类型#############
    // 浮点类型是带小数点的数字，在Rust中有两种浮点类型，f32与f64，默认使用f64，因为在现代计算机中，f32与f64速度相差无几，但f64精度更高
    // 需要注意的是：
    // -浮点数往往是你想要数字的近似表达
    // -浮点数在某些特性上是反直觉的
    // 如下例子：0.1+0.2因为精度问题，并不能严格等于0.3
    // assert_eq!(0.1 + 0.2, 0.3)
    // 如果非要比较
    assert!((0.1_f64 + 0.2 - 0.3).abs() < 0.00001);

    // #############NaN#############
    // 对于数学上未定义的值，会返回NaN，且NaN并不能用于比较
    // 可以使用 x.is_nan等方法，判断一个值是否是NaN
    let nan: f64 = (-0.42_f64).sqrt();
    if nan.is_nan() {
        println!("nan is undef number")
    }

    // #############数字运算#############
    // Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。下面代码各使用一条 let 语句来说明相应运算的用法：
    // 加法
    let _sum = 5 + 10;
    // 减法
    let _difference = 95.5 - 4.3;
    // 乘法
    let _product = 4 * 30;
    // 除法
    let _quotient = 56.7 / 32.2;
    // 求余
    let _remainder = 43 % 5;

    // #############位运算#############
    // & 位与	相同位置均为1时则为1，否则为0
    // | 位或	相同位置只要有1时则为1，否则为0
    // ^ 异或	相同位置不相同则为1，相同则为0
    // ! 位非	把位中的0和1相互取反，即0置为1，1置为0
    // << 左移	所有位向左移动指定位数，右位补0
    // >> 右移	所有位向右移动指定位数，带符号移动（正数补0，负数补1）

    // #############序列(Range)#############
    // Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 1..5，生成从 1 到 4 的连续数字，不包含 5 ；1..=5，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：
    for i in 0..=10 {
        println!("range index : {}", i)
    }
    // 序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。
    // 字符range
    for i in 'a'..='z' {
        println!("range index char : {}", i)
    }

    // #############字符类型(char)#############
    // 在Rust中，字符类型为占据4个字节的Unicode编码
    let char_medium: char = '中';
    println!("char_medium size is : {}", std::mem::size_of_val(&char_medium));

    // #############布尔(bool)#############
    // bool类型有两个值，true 和 false ，占用一个字节
    let bool_var = true;
    if bool_var {
        println!("nothing😊")
    }

    // #############单元类型#############
    // 单元类型有且只有一个值，即（）
    // main 函数就返回这个单元类型 ()，你不能说 main 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：发散函数( diverge function )，顾名思义，无法收敛的函数。
    // 例如常见的 println!() 的返回值也是单元类型 ()。
    // 再比如，你可以用 () 作为 map 的值，表示我们不关注具体的值，只关注 key。

    // #############语句和表达式#############
    // Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值，例如 [`add_with_extra()`]
    fn add_with_extra(x: i32, y: i32) -> i32 {
        let x = x + 1; // 语句
        let y = y + 5; // 语句
        x + y // 表达式
    }
    // 语句会执行一些操作但是不会返回一个值
    // 表达式会在求值后返回一个值
    // 对于 Rust 语言而言，这种基于语句（statement）和表达式（expression）的方式是非常重要的
    // 你需要能明确的区分这两个概念, 但是对于很多其它语言而言，这两个往往无需区分。基于表达式是函数式语言的重要特征，表达式总要返回值。

    // #############语句#############
    let statement = 8;
    let statement: Vec<f64> = Vec::new();
    let (statement, statement1) = ("hi", false);
    // 上述操作都是语句，他们完成了一个具体的操作，但是没有返回值
    // 由于let是语句，因此不能将语句赋值给其他值，例如下面的代码就是错误的
    // let x = (let y = 6);

    // #############表达式#############
    // 表达式会在求值后返回一个值
    // 调用一个函数是表达式，因为会返回一个值，调用宏也是表达式，用花括号包裹最终返回一个值的语句块也是表达式，总之，能返回值，它就是表达式:
    let expression = {
        let x = 3;
        x + 1
    };
    println!("The value of expression is: {}", expression);
    // 上述代码中，x + 1 是一个表达式，它会返回一个值，因此可以将其赋值给一个变量，而 let x = 3; 是一个语句，它不会返回一个值，因此不能将其赋值给一个变量，这也是为什么不能将 let 语句赋值给另一个变量的原因。
    // 表达式不能包含分号
    // 表达式如果不返回任何值，将隐式返回单元类型 ()，例如下面的代码：
    let expression = {
        let x = 3;
        x + 1;
    };
    println!("The value of expression is: {:?}", expression);

    // #############函数#############
    // fn [函数名]([参数名]:[参数类型],[参数名]:[参数类型]) -> [返回值类型] {

    // #############函数要点#############
    // -函数名与参数名必须使用snake_case风格
    // -函数的位置可以在任意位置
    // -函数的参数必须声明类型

    // #############函数参数#############
    // Rust是强类型语言，因此函数的参数必须声明类型
    fn main() {
        another_function(5, 6.1);
        fn another_function(x: i32, y: f32) {
            println!("The value of x is: {}", x);
            println!("The value of y is: {}", y);
        }
    }

    // #############函数返回值#############
    // 在语句与结构体的描述中，我们知道函数其实是一个语句块，而语句块中的最后一个表达式就是函数的返回值，例如下面的代码：
    fn plus_five(x: i32) -> i32 {
        x + 5
    }
    // 但是如果我们在函数中使用了return关键字，那么函数的返回值就是return后面的表达式，例如下面的代码：
    fn plus_five_return(x: i32) -> i32 {
        return x + 5;
    }

    // #############Rust 中的特殊返回类型#############
    // 无返回值()
    // - 如果函数没有返回值，那么返回值就是();
    // - 通过;结尾的表达式，返回值是()
    // - 如果函数返回值是()，那么可以省略返回值类型的声明，例如下面的代码
    fn main1() {
        fn no_return() {
            println!("no return");
        }
        fn no_return1() -> () {
            println!("no return");
        }
    }

    // 发散函数
    // - 发散函数是一个永远不会返回的函数，例如下面的代码：
    fn main2() {
        fn diverges() -> ! {
            panic!("This function never returns!");
        }
    }
    // - 发散函数可以被赋值给任意类型，例如下面的代码：
    fn main3() {
        fn diverges() -> ! {
            panic!("This function never returns!");
        }
        let x: i32 = diverges();
        let x: String = diverges();
    }
}




